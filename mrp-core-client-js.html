<!doctype html>
<html>

<head>
  <meta name="generator" content="JSDoc ">
  <meta charset="utf-8">
  <title>Source: mrp_core/client.js</title>
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Inconsolata:400,700|Karla:400,400i,700,700i|Noto+Serif:400,400i,700,700i&display=swap&subset=latin-ext">
  <link rel="stylesheet" href="css/baseline.css">
</head>

<body onload="prettyPrint()">
  <nav id="jsdoc-navbar" role="navigation" class="jsdoc-navbar">
    <div id="jsdoc-navbar-container">
      <div id="jsdoc-navbar-content">
        <a href="index.html" class="jsdoc-navbar-package-name">Home</a>
      </div>
    </div>
  </nav>
  <div id="jsdoc-body-container">
    <div id="jsdoc-content">
      <div id="jsdoc-content-container">
        <div id="jsdoc-banner" role="banner">
        </div>
        <div id="jsdoc-main" role="main">
          <header class="page-header">
            <h1>Source: mrp_core/client.js</h1>
          </header>
          <article>
            <pre class="prettyprint linenums"><code>//load config
configFile = LoadResourceFile(GetCurrentResourceName(), &#39;config/client.json&#39;);

config = JSON.parse(configFile);

let currentCharacter = null;
let currentSpawn = null;
let metadata = {};

/**
 * @namespace MRP_CLIENT
 */
let MRP_CLIENT = {

    /**    
     * RandomString - description    
     *      
     * @memberof MRP_CLIENT
     * @return {type}  description     
     */
    RandomString: function() {
        return Math.random().toString(36).substring(2, 15) + Math.random().toString(36).substring(2, 15);
    },


    /**    
     * Notification - description    
     *      
     * @memberof MRP_CLIENT
     * @param  {type} text     description     
     * @param  {type} duration description     
     * @return {type}          description     
     */
    Notification: function(text, duration) {
        let exec = async () =&gt; {
            SetNotificationTextEntry(&quot;STRING&quot;);
            AddTextComponentString(text);
            let notification = DrawNotification(false, false);
            await MRP_CLIENT.sleep(duration);
            RemoveNotification(notification);
        }
        exec();
    },

    /**    
     * TriggerServerCallback - description    
     *      
     * @memberof MRP_CLIENT
     * @param  {type} event    description     
     * @param  {type} args     description     
     * @param  {type} callback description     
     * @return {type}          description     
     */
    TriggerServerCallback: function(event, args, callback) {
        let requestTS = Date.now() + &quot;:&quot; + MRP_CLIENT.RandomString();
        let responseEvent = event + &quot;:response&quot;;
        let serverResponse = function(...serverResponseArgs) {
            let responseTS = serverResponseArgs[serverResponseArgs.length - 1];
            //check if this response is for the callback made
            if (requestTS != responseTS)
                return;

            removeEventListener(responseEvent, serverResponse);
            try {
                callback.call(this, ...serverResponseArgs);
            } catch (e) {
                //TODO this thing throw Error: BUFFER_SHORTAGE for some reason but everything works something to do with wrapped objects in fivem V8
                console.log(e);
                //throw e;
            }
        };
        onNet(responseEvent, serverResponse);
        let source = GetPlayerServerId(PlayerId());
        if (args) {
            let params = [event, source].concat(args);
            params.push(requestTS);
            emitNet.apply(this, params);
        } else
            emitNet(event, source);
    },

    /**    
     * GetPlayerData - description    
     *      
     * @memberof MRP_CLIENT
     * @return {type}  description     
     */
    GetPlayerData: function() {
        return currentCharacter;
    },

    /**    
     * getPlayerMetadata - description    
     *      
     * @memberof MRP_CLIENT
     * @param  {type} name description     
     * @return {type}      description     
     */
    getPlayerMetadata: function(name) {
        if (name)
            return metadata[name];

        return metadata;
    },

    /**    
     * setPlayerMetadata - description    
     *      
     * @memberof MRP_CLIENT
     * @param  {type} name  description     
     * @param  {type} state description     
     * @return {type}       description     
     */
    setPlayerMetadata: function(name, state) {
        metadata[name] = state;
    },

    /**    
     * InvokeNative - description    
     *      
     * @memberof MRP_CLIENT
     * @return {type}  description     
     */
    InvokeNative: function() {
        let args = arguments;
        return new Promise(resolve =&gt; {
            emit(&#39;mrp:lua:invokeNative&#39;, args, (returnVal) =&gt; {
                resolve(returnVal);
            });
        });
    },

    /**     
     * CreateThread - description    
     * 
     * Example with infinite while cycle:
     * MRP_CLIENT.CreateThread(()=&gt;{
     *      let cycle = async function(){
     *          let x = 0;
     *          while(true){
     *              x++;
     *              print(x);
     *              await MRP_CLIENT.sleep(2000);
     *          }
     *      }
     *      cycle();
     * });
     *      
     * @memberof MRP_CLIENT
     * @param  {type} callback description     
     * @return {type}          description     
     */
    CreateThread: function(callback) {
        emit(&#39;mrp:lua:createThread&#39;, callback);
    },

    /**    
     * sleep - description    
     *      
     * @memberof MRP_CLIENT
     * @param  {type} ms description     
     * @return {type}    description     
     */
    sleep: function(ms) {
        return new Promise((resolve) =&gt; {
            setTimeout(resolve, ms);
        });
    },

    /**    
     * wait - description    
     *      
     * @memberof MRP_CLIENT
     * @param  {type} ms description     
     * @return {type}    description     
     */
    wait: function(ms) {
        return new Promise((resolve) =&gt; {
            emit(&#39;mrp:lua:wait&#39;, ms, () =&gt; {
                resolve();
            });
        });
    },

    /**    
     * drawText3D - description    
     *      
     * @memberof MRP_CLIENT
     * @param  {type} x    description     
     * @param  {type} y    description     
     * @param  {type} z    description     
     * @param  {type} text description     
     * @return {type}      description     
     */
    drawText3D: function(x, y, z, text) {
        //TODO config not hardcoded magic numbers
        SetTextScale(0.35, 0.35);
        SetTextFont(4);
        SetTextProportional(1);
        SetTextColour(255, 255, 255, 215);
        SetTextEntry(&quot;STRING&quot;);
        SetTextCentre(true);
        AddTextComponentString(text);
        SetDrawOrigin(x, y, z, 0);
        DrawText(0.0, 0.0);
        let factor = text.length / 370;
        DrawRect(0.0, 0.0 + 0.0125, 0.017 + factor, 0.03, 0, 0, 0, 75);
        ClearDrawOrigin();
    },

    /**    
     * displayHelpText - description    
     *      
     * @memberof MRP_CLIENT
     * @param  {type} str description     
     * @return {type}     description     
     */
    displayHelpText: function(str) {
        BeginTextCommandDisplayHelp(&quot;STRING&quot;);
        AddTextComponentString(str);
        EndTextCommandDisplayHelp(0, false, true, -1);
    },

    /**    
     * isNearLocation - description    
     *      
     * @memberof MRP_CLIENT
     * @param  {type} entity description     
     * @param  {type} x      description     
     * @param  {type} y      description     
     * @param  {type} z      description     
     * @param  {type} area   description     
     * @return {type}        description     
     */
    isNearLocation: function(entity, x, y, z, area) {
        if (!area) {
            area = config.defaultNearArea;
        }

        let [entityX, entityY, entityZ] = GetEntityCoords(entity);
        let distance = Vdist(entityX, entityY, entityZ, x, y, z);
        return distance &lt;= area;
    },

    /**    
     * getEntityInFront - description    
     *      
     * @memberof MRP_CLIENT
     * @param  {type} flags description     
     * @return {type}       description     
     */
    getEntityInFront: function(flags) {
        let [plyCoordsX, plyCoordsY, plyCoordsZ] = GetEntityCoords(PlayerPedId(), false);
        let [plyOffsetX, plyOffsetY, plyOffsetZ] = GetOffsetFromEntityInWorldCoords(PlayerPedId(), 0.0, 1.2, 0.0);
        let rayHandle = StartShapeTestCapsule(plyCoordsX, plyCoordsY, plyCoordsZ, plyOffsetX, plyOffsetY, plyOffsetZ, 0.3, flags, PlayerPedId(), 7);
        let [_1, _2, _3, _4, entity] = GetShapeTestResult(rayHandle);

        return entity;
    },

    /**    
     * getVehicleInFront - description    
     *      
     * @memberof MRP_CLIENT
     * @return {type}  description     
     */
    getVehicleInFront: function() {
        return MRP_CLIENT.getEntityInFront(10);
    },

    /**    
     * getPedInFront - description    
     *      
     * @memberof MRP_CLIENT
     * @return {type}  description     
     */
    getPedInFront: function() {
        return MRP_CLIENT.getEntityInFront(12);
    },

    /**    
     * addBlips - description    
     *      
     * @memberof MRP_CLIENT
     * @param  {type} blips description     
     * @return {type}       description     
     */
    addBlips: function(blips) {
        for (let v of blips) {
            let blip = AddBlipForCoord(v.x, v.y, v.z);
            SetBlipSprite(blip, v.blip);
            SetBlipScale(blip, 0.8);
            SetBlipAsShortRange(blip, true);
            SetBlipColour(blip, v.blipColor);

            BeginTextCommandSetBlipName(&quot;STRING&quot;);
            AddTextComponentString(v.blipName);
            EndTextCommandSetBlipName(blip);
        }
    },

    /**    
     * isPedNearCoords - description    
     *      
     * @memberof MRP_CLIENT
     * @param  {type} x     description     
     * @param  {type} y     description     
     * @param  {type} z     description     
     * @param  {type} area  description     
     * @param  {type} model description     
     * @return {type}       description     
     */
    isPedNearCoords: function(x, y, z, area, model) {
        if (!area)
            area = config.defaultIsPedNearArea;

        let peds = exports[&quot;mrp_core&quot;].EnumeratePeds();
        let pedFound = false;
        for (let ped of peds) {
            let [entityX, entityY, entityZ] = GetEntityCoords(ped);
            let distance = Vdist(entityX, entityY, entityZ, x, y, z);
            if (model) {
                let entityModel = GetEntityModel(ped);
                if (entityModel != model)
                    continue;
            }

            if (distance &lt; area) {
                pedFound = true;
                break;
            }

        }

        return pedFound;
    },

    /**    
     * spawnSharedNPC - {
     *     model: &quot;a_f_m_ktown_02&quot;,
     *     x: 0,
     *     y: 0,
     *     z: 0,
     *     heading: 0
     * }
     * 
     * @memberof MRP_CLIENT     
     * @param  {type} opt options as described above
     * @return {type}     PED     
     */
    spawnSharedNPC: function(opt) {
        let exec = async () =&gt; {
            let modelHash = GetHashKey(opt.model);
            if (!MRP_CLIENT.isPedNearCoords(opt.x, opt.y, opt.z, null, modelHash)) {
                RequestModel(modelHash);
                while (!HasModelLoaded(modelHash)) {
                    await MRP_CLIENT.sleep(100);
                }

                ped = CreatePed(GetPedType(opt.model), opt.model, opt.x, opt.y, opt.z, opt.heading, true, true);
                SetBlockingOfNonTemporaryEvents(ped, true);
                SetPedKeepTask(ped, true);
                SetPedDropsWeaponsWhenDead(ped, false);
                SetPedFleeAttributes(ped, 0, 0);
                SetPedCombatAttributes(ped, 17, 1);
                SetPedSeeingRange(ped, 0.0);
                SetPedHearingRange(ped, 0.0);
                SetPedAlertness(ped, 0.0);
                SetEntityInvincible(ped, true);
            }
        };
        exec();
    }
};

on(&#39;mrp:getSharedObject&#39;, (cb) =&gt; {
    cb(MRP_CLIENT);
});

onNet(&#39;mrp:spawn&#39;, (char, spawn) =&gt; {
    if (!char &amp;&amp; currentCharacter) {
        currentCharacter = currentCharacter;
    } else if (char) {
        currentCharacter = char;
        currentSpawn = spawn;
        //reset metadata
        metadata = {
            isDead: false,
            isCuffed: false,
            isLastStand: false
        };
    } else {
        return;
    }

    let health = currentCharacter.stats.health;
    if (currentCharacter.sex == &quot;MALE&quot;) {
        //because reasons :D
        health += 100;
    }

    exports.spawnmanager.spawnPlayer(currentSpawn, () =&gt; {
        let ped = PlayerPedId();
        let pID = PlayerId();
        SetEntityHealth(ped, health);
        SetPedArmour(ped, currentCharacter.stats.armor);
        SetPlayerHealthRechargeMultiplier(pID, config.world.playerHealthRechargeMultiplier);
    });

    emitNet(&#39;mrp:characterSpawned&#39;, currentCharacter);

    //TODO test only revive for all in menu
    emit(&#39;mrp:radial_menu:addMenuItem&#39;, {
        id: &#39;revive&#39;,
        text: &#39;Revive&#39;,
        action: &#39;https://mrp_core/revive&#39;
    });
});

onNet(&#39;mrp:revive&#39;, () =&gt; {
    if (currentCharacter == null)
        return;

    let health = 100;
    currentCharacter.stats.health = health;
    if (currentCharacter.sex == &quot;MALE&quot;) {
        //because reasons :D
        health += 100;
    }

    let ped = PlayerPedId();
    let [x, y, z] = GetEntityCoords(ped, true);
    let heading = GetEntityHeading(ped);
    NetworkResurrectLocalPlayer(x, y, z, heading, true, false);
    SetPlayerInvincible(ped, false);
    SetEntityHealth(ped, health);
    SetPedArmour(ped, currentCharacter.stats.armor);
    ClearPedBloodDamage(ped);
});

function addStat(name, modifier) {
    if (currentCharacter == null)
        return;

    currentCharacter.stats[name] += modifier;

    if (currentCharacter.stats[name] &lt; 0) {
        currentCharacter.stats[name] = 0;
    } else if (currentCharacter.stats[name] &gt; 100) {
        currentCharacter.stats[name] = 100;
    }

    if (name == &quot;armor&quot;) {
        let ped = PlayerPedId();
        SetPedArmour(ped, currentCharacter.stats.armor);
    }

    if (name == &quot;health&quot;) {
        let health = currentCharacter.stats.health;
        if (currentCharacter.sex == &quot;MALE&quot;) {
            //because reasons :D
            health += 100;
        }

        let ped = PlayerPedId();
        SetEntityHealth(ped, health);
    }
}
onNet(&#39;mrp:addHunger&#39;, (modifier) =&gt; {
    addStat(&#39;hunger&#39;, modifier);
});

onNet(&#39;mrp:addThirst&#39;, (modifier) =&gt; {
    addStat(&#39;thirst&#39;, modifier);
});

onNet(&#39;mrp:addStress&#39;, (modifier) =&gt; {
    addStat(&#39;stress&#39;, modifier);
});

onNet(&#39;mrp:addArmor&#39;, (modifier) =&gt; {
    addStat(&#39;armor&#39;, modifier);
});

onNet(&#39;mrp:updateCharacter&#39;, (char) =&gt; {
    currentCharacter = char;
});

on(&#39;mrp:addHealth&#39;, (modifier) =&gt; {
    addStat(&#39;health&#39;, modifier);
});

onNet(&#39;mrp:addHealth&#39;, (modifier) =&gt; {
    addStat(&#39;health&#39;, modifier);
});

if (config.enablePVP) {
    on(&#39;playerSpawned&#39;, () =&gt; {
        setInterval(() =&gt; {
            let playerPed = PlayerPedId();

            NetworkSetFriendlyFireOption(true);
            SetCanAttackFriendly(playerPed, true, false);
        }, 0);
    });
}

RegisterNuiCallbackType(&#39;revive&#39;);
on(&#39;__cfx_nui:revive&#39;, (data, cb) =&gt; {
    emit(&#39;mrp:revive&#39;);
    cb({});
});

RegisterNuiCallbackType(&#39;closeUI&#39;);
on(&#39;__cfx_nui:closeUI&#39;, (data, cb) =&gt; {
    SetNuiFocus(false, false);
    cb({});
});

on(&#39;mrp:startTimer&#39;, (data) =&gt; {
    data.type = &#39;showCounter&#39;;
    SendNuiMessage(JSON.stringify(data));
});

onNet(&#39;mrp:popup&#39;, (data) =&gt; {
    SetNuiFocus(true, true);
    data.type = &#39;showPopup&#39;;
    SendNuiMessage(JSON.stringify(data));
});

onNet(&#39;mrp:showNotification&#39;, msg =&gt; {
    MRP_CLIENT.Notification(msg, config.notificationDuration);
});</code></pre>
          </article>
        </div>
      </div>
      <nav id="jsdoc-toc-nav" role="navigation"></nav>
    </div>
  </div>
  <footer id="jsdoc-footer" class="jsdoc-footer">
    <div id="jsdoc-footer-container">
      <p>
        Generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc</a> on July 16, 2021.
      </p>
    </div>
  </footer>
  <script src="scripts/jquery.min.js"></script>
  <script src="scripts/tree.jquery.js"></script>
  <script src="scripts/prettify.js"></script>
  <script src="scripts/jsdoc-toc.js"></script>
  <script src="scripts/linenumber.js"></script>
  <script src="scripts/scrollanchor.js"></script>
</body>

</html>